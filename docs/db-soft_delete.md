- Table of Content
{:toc}

# 論理削除についてのノート
## はじめに

本記事は論理削除についてのノートです。

論理削除のメリットとデメリットを示し、そのうえで論理削除が適す・適さないについて自分なりの考えを示します。

## 論理削除とは

論理削除 (soft delete) とはデータベースのテクニックの1つです。

とても広く普及しています。

`DELETE` でデータベースから実際にレコードを削除する (物理削除) のではなく、 `UPDATE` で `deleted_at` や `deleted_flag` のような削除フラグカラムに対して「削除した」とマークすることでそのレコードを削除したとみなします。

> [!NOTE] [論理削除をサポートする機能やテクニック](./db-soft_delete--support_function)もあります。

## 論理削除のメリット・デメリット

物理削除と比べた論理削除のメリットとデメリットは次のとおりです。

- メリット
  - 実装が容易である。
  - レコードの復元が簡単
  - 高速に削除できる (ただし微々たるものである)
  - 削除データを1世代分確認できる
- デメリット
  - 常にクエリで削除フラグを判定を加える必要がある。これは手間であり、バグの温床となりうる。またパフォーマンス劣化の要因となる。
  - 削除されたレコードが残存することでテーブルサイズが大きくなる。これはパフォーマンス劣化の要因となる。
  - ユニーク制約が使えなくなる。これはデータの整合性にとって不利である。

きわめてシンプルな方法で容易なデータ復元を実現できるのは大きな強みだと思います。実装が容易なことは確実に機能し、誰もが理解しやすい性質でもあります。

一方でバグの温床になることやデータ整合性に対して不利であることは論理削除を採用するのであれば意識すべきです。

> [!NOTE] 論理削除対応のORMを使うと削除フラグを意識しなくて済みます。


## 論理削除の代替手法：DELETEトリガーによるアーカイブ

もしもレコードをデータベース上から消滅させるのを避けたいのであれば論理削除ではなく別の方法があります。

それはトリガーによるアーカイブです。アーカイブテーブルを作成し、`DELETE` イベントで削除対象のレコードをアーカイブします。

例えば次のようにトリガーを設定することで削除の度にレコードがアーカイブされます。

(https://qiita.com/lc-xx16/items/788d82038221bca4e898 より引用)

アーカイブ関数：

```sql
CREATE FUNCTION process_backup()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN 
    INSERT INTO archive SELECT OLD.*;
    RETURN OLD;
END
$function$
```

アーカイブトリガー：

```sql
CREATE TRIGGER backup_recode 
AFTER DELETE ON product 
 FOR EACH ROW EXECUTE PROCEDURE process_backup();
```

この手法はデータの管理をデータベースに任せることができる点でスマートだと思います。アプリケーション側が削除処理の詳細 (物理削除か論理削除か) を意識しなくてよくなります。

メリットとデメリットはおおむね論理削除の逆となります。また削除データを1世代ではなく複数世代保つことができます。

- メリット
  - クエリで削除フラグを判定を加える必要がなくなる。これはバグの要因を減らせることになる。
  - 削除されたレコードが残存しないことでテーブルサイズが小さくなる。
  - ユニーク制約が使えるようになる。これはデータの整合性にとって有利である。
  - 削除データを複数世代分確認できる
- デメリット
  - データベースにトリガーの実装が必要になる。
  - レコードの復元が複雑
  - 削除の度に `INSERT` も実行されるのでパフォーマンスで劣る

## テーブルの類型と論理削除

論理削除はどのようなテーブルに適しているのかを考えてみます。

論理削除は主キー制約やユニークキー制約に強く影響します。そのため候補キー(主キーやユニークキー)の値に注目します。

では、以下に示すのようにテーブルを類型を定めます。

> [!NOTE] 例で示すテーブルはサロゲートキーは設けていません。これは説明のため単純なテーブルにしているためです。テーブルの作りによってはサロゲートキー(主キー)と自然キー(ユニークキー)のペアの制約を含まれている場合があります。

> [!NOTE] 論理削除のテクニックとして自然キーに削除フラグを含む複合キーを用いるテクニックもあります。本記事では扱いません。

なお類型を定めるにあたって基本的に **主キーの値は再利用しない原則** に従うものとして考えます。


### 主キーが自動生成キーのテーブル(注文データなど)

類型の1つは、主キーが自動生成キーとなっているタイプのテーブルです。DBの機能として同じコードが2回以上発生することはありません。

例えば注文データのようなトランザクションデータで見かけるタイプのテーブルです

| *注文ID   | 削除フラグ | 顧客ID | 日付       | ... |
|-----------|------------|--------|------------|-----|
| OD0000001 | 0          | user1  | 2024/07/01 | ... |
| OD0000002 | 0          | user2  | 2024/07/01 | ... |


### 主キーが採番ルールのあるコードのテーブル(商品マスタなど)

類型の1つは、主キーが採番ルールのあるコードになっているタイプのテーブルです。運用上同じコードが2回以上発生することはありません。

例えば商品マスタなどで見かけるタイプのテーブルです。

| *商品CD         | 削除フラグ | 商品名     | ... |
|-----------------|------------|------------|-----|
| FLO-PANG-NAE-01 | 0          | パンジー苗 | ... |
| VEG-TOMA-NAE-02 | 0          | トマト苗   | ... |
| VEG-TOMA-TAN-02 | 0          | トマト種   | ... |

合成キーではなく複合主キーの場合もあります。

| *モデル | *版 | 削除フラグ | 商品分類 | ... |
|---------|-----|------------|----------|-----|
| md-1005 | 1   | 0          | keyboard | ... |
| md-4003 | 1   | 0          | mouse    | ... |
| md-4003 | 2   | 0          | mouse    | ... |

### 主キーが外部キーのみの複合キーのテーブル(中間テーブル)

類型の1つは、主キーが外部キー(他テーブルの主キー項目)のみで構成される複合キーとなっているタイプのテーブルです。

> [!NOTE] このようなテーブルは中間テーブル (連想テーブル, 交差テーブル, etc...) と呼ばれます。

例えば役割の権限などで見かけるタイプのテーブルです。

| *役割CD | *機能CD | 削除フラグ | ... |
|---------|---------|------------|-----|
| role-1  | func-1  | 0          | ... |
| role-1  | func-2  | 0          | ... |
| role-2  | func-2  | 1          | ... |

### 主キーが外部キーを含む複合キーのテーブル(明細テーブル)

類型の1つは、主キーが外部キーと自動採番で構成される複合キーとなっているタイプのテーブルです。ようするに明細テーブルです。

例えば注文データに対する注文明細データのようなタイプのテーブルです。

| *注文ID | *明細番号 | 削除フラグ | ... |
|---------|-----------|------------|-----|
| ord-1   | 1         | 0          | ... |
| ord-1   | 2         | 1          | ... |
| ord-1   | 3         | 0          | ... |

### 主キーがシステムの処理と紐づいているコードのテーブル(区分マスタ)

類型の1つは、主キーがシステムの処理と紐づいているコードのテーブルです。各種区分やステータスのマスタテーブルです。

例えば雇用区分のようなテーブルです。

| *雇用区分CD | 名前     | 削除フラグ | ... |
|-------------|----------|------------|-----|
| emp-regular | 正社員   | 0          | ... |
| emp-short   | 契約社員 | 0          | ... |
| emp-part    | パート   | 0          | ... |

### 候補キー以外でユニーク制約を持つテーブル

上記で示したテーブルでも候補キー(主キーや主キーとなりうるキー)以外でユニーク制約を持つテーブルもあります。

例えばログインで用いるユーザマスタにメールアドレスのユニーク制約がある場合です。

| *ユーザID | 削除フラグ | ユーザ名     | (UK)メールアドレス            | ... |
|-----------|------------|--------------|-------------------------------|-----|
| 1         | 0          | tokyo taro   | tokyo.taro@example.com        | ... |
| 2         | 0          | osaka hanako | osaka.hanako.2304@example.com | ... |
| 3         | 1          | osaka hanako |                               | ... |

このタイプでは、削除したレコードのユニーク制約のあるカラムの値が別のレコードで使われる可能性があります。


### 各テーブルの類型と論理削除との相性

各テーブルの類型と論理削除との相性を考えてみます。

まず、「常にクエリで削除フラグを判定を加える必要がある」という点はどのような類型であっても変わりません。

次に「削除されたレコードが残存することでテーブルサイズが大きくなる」もどのような類型でも変わりません。とはいえ論理削除による影響が深刻になるケースは基本的には無いと考えます。

> [!NOTE] `WHERE` 句や `ON` 句の書き方によっては削除フラグによって検索時にインデックスが使われないことがあるかもしれません。

「ユニーク制約が使えなくなる」という点はテーブルの類型によって困る場合と困らない場合があると考えます。主キー制約も含めて次の表に示します。

| テーブルの類型                                                   | 主キー制約・ユニーク制約                                           |
|------------------------------------------------------------------|--------------------------------------------------------------------|
| 主キーが自動生成キーのテーブル(注文データなど)                   | 🟢 問題なし。                                                      |
| 主キーが採番ルールのあるコードのテーブル(商品マスタなど)         | 🟢 問題なし。[*1]                                                  |
| 主キーが外部キーのみの複合キーのテーブル(中間テーブル)           | 🟢 問題なし。[*1]                                                  |
| 主キーが外部キーを含む複合キーのテーブル(明細テーブル)           | 🟢 問題なし。                                                      |
| 主キーがシステムの処理と紐づいているコードのテーブル(区分マスタ) | 🟢 問題なし。[*1]                                                  |
| 候補キー以外でユニーク制約を持つテーブル                         | ❌️ 問題あり。論理削除レコードにある値を別のレコードに割り当てられない。 |

> [!WARNING] [*1]: 通常あるべきではないですが、削除したレコードの主キーの値を別のレコードに再利用する場合は問題ありです。

このようにまとめてみると論理削除は主キー制約においては問題は生じないように思えます。むしろ値の再利用を確実に防止できていることが安心でさえあります。

一方で候補キー以外のユニーク制約では明確に問題ありです。論理削除レコードにある値を別のレコードに割り当てられないため、本来設定すべきユニーク制約を設定することができません。

### 論理削除はあくまで削除である

「論理削除」。これは削除ですか？　それとも無効ステータスですか？

例えばPHPのフレームワークLaravelのORMでは論理削除(ソフトデリート)は基本的に物理削除と同じように論理削除したレコードは見えません。意識的に `withTrashed()` という特殊な書き方で見えるようになります。

例えばOracleのIn-Database Archivingでも論理削除は基本的に論理削除したレコードは見えません。意識的に `ALTER SESSION SET ROW ARCHIVAL VISIBILITY = ALL;` を実行することで見えるようになります。

これは「論理削除はあくまで削除である」という考えが根底にあると思います。


分かりやすさを求めるのであれば、私は「論理削除」はあくまで削除であるという方針が良いと思います。

論理削除されたレコードはアプリケーションコードからは基本的に見えないようにします。論理削除されたレコードを見る時はレコードの復活を行う時に限定するようにします。


## まとめ

論理削除はきわめてシンプルな方法で容易なデータ復元を実現できるのは大きな強みです。また削除されたデータを確認できることはデバッグやトラブルシューティングで役立ちます。

また論理削除は主キーの再利用防止に役立ちます。

一方で論理削除はデータ整合性に関しては不利となり、バグの温床になりえます。削除フラグの判定が常に必要になり、ユニーク制約と相性が悪いです。

論理削除のユニーク制約の面に関しては、主キーが再利用されることが無い、候補キー以外にユニークインデックスが無い、場合であればおおむね問題は少ないと考えます。特に自動採番のトランザクションデータで採用するのであれば効果的だと考えます。

「論理削除はあくまで削除である」と考え、アプリケーションコードでは論理削除されたデータを対象とした処理を書くべきではないと思います。例外は論理削除レコードの復活です。


# 参考文献
## 全般
* Soft deletes are tedious! Does an ideal deletion without loss even exist?, https://medium.com/geekculture/soft-deletes-are-tedious-does-an-ideal-deletion-without-loss-even-exist-9cc5d78e9b10
* Creating a Soft Delete Archive Table with PostgreSQL, ttps://medium.com/meroxa/creating-a-soft-delete-archive-table-with-postgresql-70ba2eb6baf3
* 論理的な削除と物理的な削除, https://abstraction.blog/2015/06/28/soft-vs-hard-delete#comparison-factors
* What Are Soft Deletes, and How Are They Implemented?, https://www.brentozar.com/archive/2020/02/what-are-soft-deletes-and-how-are-they-implemented/

## In-Database Archiving
* インデータベースアーカイブの使用, https://docs.oracle.com/database/121/VLDBG/GUID-5A76B6CE-C96D-49EE-9A89-0A2CB993A933.htm
* Oracle Database 12c の論理削除機能を試す, https://qiita.com/plusultra/items/0c9dcb9992bbb664f6c0
* Oracle Database 12cリリース1 (12.1)でのインデータベース・アーカイブ, https://oracle-base.com/articles/12c/in-database-archiving-12cr1

## Laravelのソフトデリート
* ソフトデリート, https://readouble.com/laravel/10.x/ja/eloquent.html#soft-deleting
