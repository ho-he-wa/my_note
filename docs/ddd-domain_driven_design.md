# ドメイン駆動設計についてのノート
## はじめに

基本的には「ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本」を読んでのメモ。

その他、ドメイン駆動設計について調べたことについても記す。

## アプリケーションを実現するためのパターンとドメインの知識を実現するためのパターン

ドメイン駆動設計(DDD)のオブジェクトは次のように大きく2つに分かれます。

* アプリケーションを実現するためのパターン
  * アプリケーションサービス
  * ファクトリ
  * リポジトリ
* ドメインの知識を実現するためのパターン
  * 値オブジェクト
  * エンティティ
  * ドメインサービス
  * 仕様オブジェクト
  * 集約

これらのオブジェクトは、アプリケーションアーキテクチャを4層(プレゼンテーション、ユースケース、ドメイン、インフラストラクチャ)で表すと、次の図のように位置します。

![各レイヤーとオブジェクト](./ddd-domain_driven_design/ddd-patterns.drawio.svg)

以降に各オブジェクトについての記します。

## ドメインの知識を実現するためのパターン

### 値オブジェクト

値単独あるいは値の組合せの小さなオブジェクトです。

例えばユーザーID、金額(数値と単位の組)、郵便番号、電話番号、住所、年齢、色などです。

次のような特徴を持ちます。

- 不変 (イミュータブル)
- 交換可能 (値オブジェクトの中身を変更しない。値オブジェクトを差し替える)
- 等価性で比較 (値オブジェクトが持つ属性が同じであれば同じ)

値オブジェクトが別の値オブジェクトを持つ入れ子構造もあります。

値オブジェクトにgetterは無い方がデメテルの法則を違反することがないため望ましいでしょうが、少なくとも永続化で必要となります。必要であればgetterを追加しましょう。

#### Always-Valid Domain Model

Always-Valid Domain Modelは、ドメインオブジェクトは常に正しい状態にするという考えです。

つまりはオブジェクト生成時にそのドメインオブジェクトの仕様を満たしているかの検証を行ってエラーになるのであれば生成を許しません。

### エンティティ

idによって区別されるデータのかたまりです。

例えばユーザー、製品、契約などです。

次のような特徴を持ちます。

- 可変 (ミュータブル)
- 同じ属性であっても区別される (例えば同姓同名でも別人)
- 同一性(id)により区別される

### ドメインサービス

エンティティや値オブジェクトに記述すると不自然な振る舞いを記述するオブジェクトです。

例えば、ユーザの重複確認、輸送の出庫入庫、口座の入金出勤です。

値オブジェクトやエンティティと異なり、自身の振る舞いを変更するようなインスタンス特有の状態を持ちません。

とはいえインスタンス変数を一切持たないわけではなく、インスタンス変数にリポジトリを持つことはあります。

> [!NOTE] ドメインサービスの命名 ... 「ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本」では、(1)サフィックス無し、(2)サフィックス　`-Service` 、(3)サフィックス `-DomainService` の命名が示されています。その著者は(2)を採用することが多いようです。

> [!NOTE] ドメインオブジェクト ... DDDの用語の中にドメインオブジェクトがあります。しかし厳密な定義がわかりません。少なくとも値オブジェクトとエンティティは含まれるようです。おそらく上述の「ドメインの知識を実現するためのパターン」に含まれるオブジェクトのことだとは思うのですがいまいち確信が持てません。現時点では「エリック・エヴァンスのドメイン駆動設計」は未読です。

### 集約

集約はあるエンティティを起点としたオブジェクトのまとまりです。

例えば、注文と注文明細、チームとチームメンバー、などです。

集約(Aggregate)は1つ以上のエンティティで構成されます。複数の子エンティティと値オブジェクトを持つことができます。

子エンティティではなくエンティティのIDを持つ作りもありです。

集約というオブジェクトがあるわけではありません。

起点となるエンティティは集約ルートと呼ばれます。集約内のエンティティを変更する時は必ず集約ルートを経由します。これにより集約の一貫性が維持されます。

後述のリポジトリは集約ルートとなるエンティティに対応しています。そのため集約はリポジトリに入出力する単位といえます。

### 仕様オブジェクト

前述のAlways-Valid Domain Modelの考えからドメインオブジェクトは生成時にドメインオブジェクトの仕様を満たしているかの検証を行います。

検証ロジックをドメインオブジェクト自身に持たせることも考えられますが、これではその検証処理でオブジェクトが肥大化していきます。

仕様オブジェクトはその検証処理をオブジェクトに独立させたオブジェクトです。`XxxSpecification.isSatisfiedBy(評価対象のドメインオブジェクト)` という形で検証を行います。

ドメインオブジェクト生成時の検証で使う場合もありますが、リポジトリの検索条件に仕様オブジェクトを用いると、検索ロジックをドメインにまとめられます。しかしパフォーマンスで難があります。

## アプリケーションを実現するためのパターン

### アプリケーションサービス

アプリケーションサービスではユースケースを実現します。

ドメインオブジェクトのタスク調整に徹するべきです。

1つのユースケースをアプリケーションサービスの1つのメソッドにすることもあれば、1つのユースケースで1つのアプリケーションサービスのオブジェクトにすることもあります。

アプリケーション層からプレゼンテーション層に結果を呼び出し側に返す時は、ドメインを保護するためにDTOに変換して戻り値とすべきです。


> [!NOTE] アプリケーションサービスの命名 ... 「ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本」ではサフィックス `-ApplicationService` の命名が示されています。

#### アプリケーションサービスの戻り値とDTO

DTO (Data Transfer Object) は読み取り専用の単純なオブジェクトです。ビジネスロジックを持ちません。

アプリケーションサービスでのDTOでは、コンストラクタで元データとなるドメインオブジェクトを引数として受け取ると修正箇所をまとめることができます。

アプリケーション層からプレゼンテーション層に結果を返す時は、DTOを使わずにドメインオブジェクトそのものを戻り値とする方法が考えられます。

ドメインオブジェクトそのものを戻り値とする方法は処理自体を単純にします。一方でドメインオブジェクトに対する依存が発生するため、ドメインオブジェクトが変更された場合はアプリケーションサービスの呼び出し側も変更する必要があります。そのためDTOが推奨されます。

DTOではなくDPO (Domain Payload Object) を用いる方法もありますが詳しく知りません。

> [!NOTE] DTOの命名 ... アプリケーションサービスでのDTOは、「ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本」ではサフィックス `-Data` の命名が示されています。

#### 通知オブジェクト

アプリケーションの呼び出し側に値を返す方法として通知オブジェクトという方法もあります。

ドメインオブジェクトに通知用メソッドを用意し、引数の通知オブジェクトに値を渡す方法です。

ドメインオブジェクトの内部情報を非公開にしたままで値を呼び出し側に渡せる方法です。欠点としてコードの記述量が大幅に増えます。

#### コマンドオブジェクト

例えばユーザー情報の更新のアプリケーションサービスでは、「名前だけ変更したい」や「電話番号と住所を変更したい」のように更新対象の値が多様である場合があります。

このような場合に、アプリケーションサービスのメソッドのパラメータにコマンドオブジェクトを用います。

コマンドオブジェクトについての詳細は割愛します。ざっくりいえばアプリケーションサービスの複雑なパラメータをラップしたオブジェクトです。

### リポジトリ

ドメインオブジェクトの永続化や再構築を行うオブジェクトです。

データの永続化や再構築を抽象的に扱うことでソフトウェアに柔軟性を与えます。

リポジトリを介することでデータストアの切り替えをしやすくできます。

またリポジトリ同じインタフェースを実装すればテスト用のインメモリで動作するリポジトリを用意できます。何らかのインメモリデータベースを使う必要はなく連想配列でかまいません。連想配列を使うのであればテスト用なので実体の連想配列をpublicにすると便利です。

リポジトリと似た概念でDAO(Data Access Object)があります。リポジトリとDAOを比べると次のようになります。

* リポジトリ ... 「ドメインオブジェクトのコレクション」のような振る舞いとなります。戻り値や引数はドメインオブジェクトです。
* DAO ... DBやAPIの操作を隠蔽します。戻り値や引数は汎用的なオブジェクトや配列の場合もあります。

リポジトリがDAOやORMを用いることは普通にありえます。

> [!NOTE] とはいえ理想的には行かない ... 「ビジネスロジックはドメインに閉じ込める」のが理想です。例えばデータの検索処理はリポジトリではなくドメイン側にあるべきです。しかしパフォーマンスの都合上リポジトリに持たせてしまうことが多くなります。またトランザクション処理(コミット・ロールバック)の有無を踏まえると、データストアの切り替えがしやすくなるとはいっても限度があります。

#### データの整合性・トランザクション

トランザクションはアプリケーションサービスに書きます。

データの整合性を保つ方法として次のようなパターンがあります。

* トランザクションを取り扱うパターン
  * リポジトリがDBコネクションを受け取って扱う。
  * 実装が容易であるがアプリケーションサービスにDBのコネクション(インフラストラクチャ層のオブジェクト)への依存が生じる
* トランザクションスコープやAOPを利用するパターン
  * .NETであればトランザクションスコープを用いる。Javaであれば@Transactionアノテーションを用いる。
* ユニットオブワークを利用するパターン
  * ユニットオブワークはオブジェクトの変更を記録するオブジェクト。
  * トランザクションを取り扱う場合はユニットオブワークを介してリポジトリを取得する。
  * リポジトリが増加するたびにユニットオブワークに修正が必要。ただしジェネリクスを使えば回避できる。
  * Entity FrameworkのDbContextにはUnit of Workを実装している。NHibernate の ITransaction インターフェイス、LINQ to SQL の DataContext クラス、Entity Framework の ObjectContext クラス、DoctorineのEntityManagerも同様。


### ファクトリ

複雑なオブジェクトの生成を行うオブジェクトです。

例えば採番処理をともなうインスタンス生成はファクトリに配置します。(リポジトリに採番メソッドを用意するのもありです)

詳細は割愛します。


### リポジトリやアプリケーションの依存の解決

リポジトリやアプリケーションサービスの依存の解決には次のような方法があります。

* Service Locatorパターン
* IoC Connectorパターン

Service Locatorパターンでは、グローバルなService Locatorクラスにリポジトリやアプリケーションサービスを登録します。欠点として依存関係が外部から見えづらくなります。またService Locatorを使うことを知っておく必要があります。

IoC Connectorパターンについてはよくわかりません。

いずれの方法でも登録処理はスタートアップスクリプトで行います。

## パッケージ構成

パッケージ構成を参考用に記します。ネットで構成例を見たところ階層の順番やまとまりは多少変動があります。

### アプリケーションレイヤー

* `Application` or `UseCases`
  * ユースケースのグループ ... (ex) Users, Circles
    * ユースケース ... (ex) Create, Get
      * アプリケーションサービス
      * アプリケーションサービスのIF
      * コマンドオブジェクト
      * DTO
      * Result型 (戻り値をResult型)

> [!NOTE] Result型 ... 「Good Code, Bad Code」の4章で示されているデザインパターン。Swift, Kotlin, Dart, Scala, Rustでは採用されているらしい。

### ドメインレイヤー

* `Domain`
  * `Models` ... ドメインオブジェクト
    * ドメインオブジェクトのまとまり ... 集約ルートごと (ex) Users, Circles
      * 値オブジェクト
      * エンティティ
      * リポジトリのIF
      * 仕様オブジェクト
      * ファクトリのIF
  * `Services`
    * ドメインサービス ... (ex) UserService
  * `Shared`
    * etc... ... 仕様オブジェクトの共通インタフェースなど

### インフラストラクチャレイヤー

* `Infrastructure` or `Infra`
  * 技術基盤 ... (ex) DB, InMemory
    * リポジトリのまとまり ... ドメインオブジェクトの集約ルートに対応する (ex) Users, Circles
      * リポジトリ

> [!NOTE] ファクトリの配置 ... 「ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本」ではInfrastructure配下にファクトリがあるが、WebでDDDのディレクトリ構造をいくつか見るとDomain配下も珍しくない。

### プレゼンテーション(UI)

* app
  * `Application`
    * ...
  * `Domain`
    * ...
  * `Infrastructure`
    * ...
  * `Http` ... Presentation
    * etc... ... コントローラ、リクエスト、ミドルウェアなど

### 異なるコンテキスト

規模が大きくなり境界づけられたコンテキストを意識すると次のようになる。

* 境界づけられたコンテキスト ... (ex) 販売コンテキスト、配送コンテキスト
  * `Application`
    * ...
  * `Domain`
    * ...
  * `Infrastructure`
    * ...
* `Http`
    * ...

## 参考文献

* 「ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本」, 成瀬允宣
* https://nrslib.com/bottomup-ddd-2/
* https://learn.microsoft.com/ja-jp/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model
* https://learn.microsoft.com/ja-jp/azure/architecture/microservices/model/tactical-ddd
* https://vaadin.com/blog/ddd-part-3-domain-driven-design-and-the-hexagonal-architecture

Unit of Work:

* https://learn.microsoft.com/ja-jp/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance
* https://bliki-ja.github.io/pofeaa/UnitofWork