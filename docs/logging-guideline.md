- Table of Content
{:toc}

# ロギングのガイドライン

## エラーログ

エラー発生時に記録するログ。
システム例外であればフレームワークやミドルウェアでのグローバルなエラー処理でロギングすべき。なおビジネス例外は後述する情報ログとして記録すること。
トラブルシューティングに用いるのでコンテキスト (処理に影響のあるデータ) を必ず出力すること。出力頻度は少ないため1回のログ記録のサイズが大きくなってもよい。

- 日時
- ログレベル (ERROR、CRITICAL、FATAL)
- メッセージ (何の処理、何が起きたか)
- コンテキスト (例：メソッドパラメータ、インスタンス変数、処理中に取得したデータ)
- スタックトレース
- エラーコード (エラーコードに関して定めがある場合は出力する)

## 警告ログ

処理続行するものの将来エラーになりうるような予兆を記録するログ。
最初はフレームワークやOS、DBが出力するものだけで十分である。また情報ログの蓄積から導出できる内容であれば警告ログに記録する必要はない。
新たに警告ログを組み込む場合、何かしらの関心が生じた場合に組み込めばよい。例えば「廃止を告知している旧APIの利用」は警告ログとしての記録がよいと考える。

- 日時
- ログレベル (WARNING、NOTICE)
- メッセージ (何の処理、何が起きたか)
- コンテキスト


## 情報ログ

ユースケース(アプリケーションサービス)やコントローラのような大きな単位で記録するログ。
開始、終了、エラー、重要な中間時点でロギングする。
情報ログに記録するエラーは、システム例外ではなくビジネス例外に関するものである。
情報ログは「何がどれだけ行われたか」といった統計的な分析にも役立つため、継続的な出力が望ましい。

- 日時
- ログレベル (INFO)
- メッセージ (処理名、処理の状態(開始/終了/エラー))
    - 処理名は非開発者（運用者や企画者）にも理解できる名称とすること

## デバッグログ

開発者や保守運用者視点で関心のある箇所で記録するログ。
基本的に本番運用では出力を抑制する。

- 日時
- ログレベル (DEBUG、TRACE)
- メッセージ
- コンテキスト
- 場所 (クラス、メソッド)


## 監査ログ

いつ、誰が、何を操作／アクセスしたか、処理結果を記録するログ。
他のログと異なりDBに保存することが多い。そのためキャパシティやパフォーマンスへの影響に注意が必要。
非機能要件として定められ、どのような関心で記録するかで出力項目が増減しやすい。
トランザクションデータに更新者・更新日時を記録するのは簡易な監査ログと言える。

- 日時
- ログレベル (ログレベルは通常のログとは混在しないため省略可能（必要に応じて "AUDIT" を付与）)
- 操作者の識別名
- 何を操作／アクセスしたか
- 処理の状態（開始、成功、失敗など）
- コンテキスト
- その他関心に応じて（例：IPアドレス、端末ID、リクエスト元など）

## エラーログのメッセージとコンテキスト

例外を元にエラーログを出力する場合は、例外をスローする時点でメッセージにコンテキストを含める。 
これは一般的な例外クラスではコンテキスト（処理中の変数など）を独立して保持・参照する手段がないためである。 
コンテキストを保持しやすくするためにカスタム例外クラスを定義する方法もあるが、多くの場合そこまでの実装は不要である。

メッセージにコンテキストを含める場合の例を以下に示す。後者の形式のほうが情報量を増やしやすく、必要に応じて機械解析もしやすい。

- 「The file report-20250101.pdf is not found.」
- 「The file is not found. - {"filename" : "report-20250101.pdf"}」


## 注意

- コンテキストの出力では重要データはマスクすること (例：クレジットカード番号や電話番号は下位4桁のみ以外をマスクする)
- ログは解析容易な形式が望ましい
    - ログの先頭（タイムスタンプ、ホスト名、アプリケーション名など）は、一般的にスペース区切りでも問題ない
    - それ以降のメッセージやコンテキスト部分では、区切りが曖昧にならないよう明確なセパレータ（例：「 - 」「 | 」など）を使用する
    - 特にgrepとの相性をよくするためにはログ出力に含まれる改行はエスケープして1行にするとよい
    - ただしスタックトレースについては改行を保ったままログ出力の2行目以降に出力するほうが実用的である
