- Table of Content
{:toc}

# ロギングのガイドライン

- ログはどの処理のタイミングで出力すべきか？
- ログにはどのような情報を含めるべきか？

ログを実装する際、こうした判断に迷うことがある。

本ガイドラインは、筆者の過去の経験や知識に基づいた指針を整理したものである。

## ログの種類と方針

### エラーログ (Error log)

エラー発生時に記録するログ。

システム例外であればフレームワークやミドルウェアでのグローバルなエラー処理でロギングすべき。なおビジネス例外は後述する情報ログとして記録すること。

トラブルシューティングに用いるのでコンテキスト (処理に影響のあるデータ) を必ず出力すること。出力頻度は少ないため1回のログ記録のサイズが大きくなってもよい。

エラーログのうちCRITICALやFATALのログ出力は、通常はフレームワークやミドルウェア側で処理されるものであり、アプリケーションコードから明示的に出力する必要は基本的にない。運用上明確に区別したい場合など、特別なケースにおいて使用を検討する。

- 日時
- ログレベル (ERROR、CRITICAL、FATAL。基本的にERRORを使う)
- メッセージ (何の処理、何が起きたか)
- コンテキスト (例：メソッドパラメータ、インスタンス変数、処理中に取得したデータ)
- スタックトレース
- エラーコード (エラーコードに関して定めがある場合は出力する)

### 警告ログ (Warning log)

処理続行するものの将来エラーになりうるような予兆を記録するログ。

最初はフレームワークやOS、DBが出力するものだけで十分である。また情報ログの蓄積から導出できる内容であれば警告ログに記録する必要はない。

新たに警告ログを組み込む場合、何かしらの関心が生じた場合に組み込めばよい。例えば「廃止を告知している旧APIの利用」は警告ログとしての記録がよいと考える。

- 日時
- ログレベル (WARNING)
- メッセージ (何の処理、何が起きたか)
- コンテキスト

### 注意ログ (Notice log)

注目・注意すべき情報を記録するログ。

警告ログと異なり、あくまで正常な状態であることを示すログである。

例えば定期バッチ処理の開始・停止、重要な処理の開始・停止、設定の再読み込みなどが該当する。

後述の情報ログと違いがわかりにくいが、監視・通知の対象となるようなログと考えればよい。

なおロギングライブラリによってはログレベルにNOTICEが無く、INFOにまとめらている場合がある。

- 日時
- ログレベル (NOTICE ※無ければINFOで代用)
- メッセージ (処理名、処理の状態(開始/終了/...))
    - 処理名は非開発者（運用者や企画者）にも理解できる名称とすること

### 情報ログ (Information log)

ユースケース(アプリケーションサービス)やコントローラのような大きな単位で記録するログ。

開始、終了、エラー、重要な中間時点でロギングする。

情報ログに記録するエラーは、システム例外ではなくビジネス例外に関するものである。

情報ログは「何がどれだけ行われたか」といった統計的な分析にも役立つため、継続的な出力が望ましい。

- 日時
- ログレベル (INFO)
- メッセージ (処理名、処理の状態(開始/終了/エラー/...))
    - 処理名は非開発者（運用者や企画者）にも理解できる名称とすること

### デバッグログ (Debug log)

開発者や保守運用者視点で関心のある箇所で記録するログ。

基本的に本番運用では出力を抑制する。

TRACEのログは、処理の流れを1ステップ～数ステップ単位で記録するような詳細なデバッグログである。通常使うことはない。

- 日時
- ログレベル (DEBUG、TRACE)
- メッセージ
- コンテキスト
- 場所 (クラス、メソッド)

### 監査ログ (Audit log)

いつ、誰が、何を操作／アクセスしたか、処理結果を記録するログ。

他のログと異なりDBに保存することが多い。そのためキャパシティやパフォーマンスへの影響に注意が必要。

非機能要件として定められ、どのような関心で記録するかで出力項目が増減しやすい。

テーブルのレコードに更新者・更新日時を記録するのは簡易な監査ログと言える。

- 日時
- ログレベル (ログレベルは通常のログとは混在しないため省略可能（必要に応じて "AUDIT" を付与）)
- 操作者の識別名
- 何を操作／アクセスしたか
- 処理の状態（開始、成功、失敗など）
- コンテキスト
- その他関心に応じて（例：IPアドレス、端末ID、リクエスト元など）

## エラーログのメッセージとコンテキスト

例外を元にエラーログを出力する場合は、例外をスローする時点でメッセージにコンテキストを含める。

これは一般的な例外クラスではコンテキスト（処理中の変数など）を独立して保持・参照する手段がないためである。

コンテキストを保持しやすくするためにカスタム例外クラスを定義する方法もあるが、多くの場合そこまでの実装は不要である。

メッセージにコンテキストを含める場合の例を以下に示す。後者の形式のほうが情報量を増やしやすく、必要に応じて機械解析もしやすい。

- 「The file report-20250101.pdf is not found.」
- 「The file is not found. - {"filename" : "report-20250101.pdf"}」

## マスク

ログには個人情報や機密情報などの重要データはなるべく出力しない。
トラブルシューティングのためにデータの一部が必要な場合は必ず大部分をマスクする。

- 例：クレジットカード番号 : #### #### #### 3456
- 例：電話番号 : 090-####-####

## 分析可能

ログはトラブルシューティングのため、あるいは何かしらの分析のために利用される。そのため分析容易な形式が望ましい。

- 特にgrepとの相性をよくするためにはログ出力に含まれる改行はエスケープして1行にするとよい
- ログのテキストを項目ごとに分解できるようにする
    - ログの先頭（タイムスタンプ、ホスト名、アプリケーション名など）は、一般的にスペース区切りでも問題ない
    - それ以降のメッセージやコンテキスト部分では、区切りが曖昧にならないよう明確なセパレータ（例：「` - `」,「 ` | `」など）を使用する
- ただしスタックトレースについては改行を保ったままにしてログ出力の2行目以降に出力するほうが実用的である
