- Table of Content
{:toc}

# ロギングのガイドライン

- ログはどの処理のタイミングで記録すべきか？
- ログにはどのような情報を含めるべきか？

ログを実装する際、こうした判断に迷うことがある。

本ガイドラインは、ロギングについて筆者の過去の経験や知識に基づいた指針を整理したものである。

対象はアプリケーションコードを主とし、バッチ処理などについては必要に応じて言及する。

## ログの種類と方針

### エラーログ (Error log)

エラー発生時に記録するログ。

システム例外であればできるだけフレームワークやミドルウェアでのグローバルなエラー処理でログを記録する。

一方、ビジネス例外 (例：在庫切れ、利用制限、支払残高不足、認証・認可エラー) は原則として後述する情報ログとして記録する。
ただし、バッチ処理において処理を正常に完了できない原因となる場合は、エラーログとして記録する方が望ましい。

トラブルシューティングを目的とするため、処理に影響を与えるデータ（コンテキスト）は必ず含めること。記録頻度は高くないため、1件あたりのログサイズが多少大きくなっても問題ない。

エラーログのうちCRITICALやFATALのログは、通常はフレームワークやミドルウェア側で処理されるものであり、アプリケーションコードから明示的に記録する必要は基本的にない。運用上明確に区別したい場合など、特別なケースにおいて使用を検討する。

- 日時
- ログレベル (ERROR、CRITICAL、FATAL。基本的にERRORを使う)
- メッセージ
  - 処理名 / 処理内容
  - 発生した事象
- コンテキスト (例：メソッドパラメータ、インスタンス変数、処理中に取得したデータ)
- スタックトレース
- エラーコード (エラーコードに関して定めがある場合は記録する)

### 警告ログ (Warning log)

処理続行するものの将来エラーになりうるような予兆を記録するログ。

最初はフレームワークやOS、DBが出力するものだけで十分である。また情報ログの蓄積から導出できる内容であれば警告ログに記録する必要はない。

新たに警告ログを組み込む場合、何かしらの関心が生じた場合に組み込めばよい。例えば「廃止を告知している旧APIの利用」は警告ログとしての記録がよいと考える。

- 日時
- ログレベル (WARNING)
- メッセージ
  - 処理名 / 処理内容
  - 発生した事象
- コンテキスト

### 注意ログ (Notice log)

注目・注意すべき情報を記録するログ。

警告ログと異なり、あくまで正常な状態であることを示すログである。

例えば定期バッチ処理の開始・停止、重要な処理の開始・停止、設定の再読み込みなどが該当する。

後述の情報ログと違いがわかりにくいが、監視・通知の対象となるようなログと考えればよい。

なおロギングライブラリによってはログレベルにNOTICEが無く、INFOにまとめらている場合がある。

- 日時
- ログレベル (NOTICE ※無ければINFOで代用)
- メッセージ
  - 処理名 ... 処理名は非開発者 (運用者や企画者) にも理解できる名称とすること
  - 処理の状態 (開始、終了など)

### 情報ログ (Information log)

ユースケース(アプリケーションサービス)やコントローラのような大きな単位で記録するログ。

開始、終了、エラー、重要な中間時点で記録する。

情報ログに記録するエラーは主にビジネス例外に関してである。例えば、在庫切れ、利用制限、支払残高不足、認証・認可エラーがある。

情報ログは膨大な量になりやすい。そのため、業務としてありふれた事象であったり、ユーザー操作による修正・リトライが行われるのであれば、特段記録する必要はない。

情報ログは「何がどれだけ行われたか」といった統計的な分析にも役立つため、継続的な記録が望ましい。

デバッグやトラブルシューティングを目的としたものではないため、コンテキスト情報の記録は最低限でよい。予約番号などの処理の識別番号があれば概ね事足りる。

- 日時
- ログレベル (INFO)
- メッセージ
  - 処理名 ... 処理名は非開発者 (運用者や企画者) にも理解できる名称とすること
  - 処理の状態 (開始、終了など)
  - 処理の識別番号 (予約番号、注文ID、取引ID、セッションIDなど)

### デバッグログ (Debug log)

開発者や保守運用者視点で関心のある箇所で記録するログ。

基本的に本番運用では記録を抑制する。

TRACEのログは、処理の流れを1ステップ～数ステップ単位で記録するような詳細なデバッグログである。パフォーマンスや出力量の観点から通常は使用しない。

- 日時
- ログレベル (DEBUG、TRACE)
- メッセージ
- コンテキスト
- 場所 (例：クラス、メソッド、行)

### 監査ログ (Audit log)

いつ、誰が、何を操作／アクセスしたか、処理結果を記録するログ。

他のログと異なりDBに保存することが多い。そのためキャパシティやパフォーマンスへの影響に注意が必要。

非機能要件として定められ、どのような関心で記録するかで記録項目が増減しやすい。

テーブルのレコードに更新者・更新日時を記録するのは簡易な監査ログと言える。

- 日時
- ログレベル (ログレベルは通常のログとは混在しないため省略可能 (必要に応じて "AUDIT" を付与) )
- 操作者の識別名（例：ユーザーID。操作責任の追跡のため）
- 何を操作／アクセスしたか
- 処理の状態 (開始、成功、失敗など)
- コンテキスト
- 接続元 (例：IPアドレス、端末名)
- その他関心に応じて (例：ブラウザのユーザーエージェントなど)

## 例外メッセージとロギング

例外を元にエラーログを記録する場合は、例外をスローする時点でメッセージにコンテキストを含める。

これは一般的な例外クラスではコンテキスト (処理中の変数など) を独立して保持・参照する手段がないためである。

コンテキストを保持しやすくするためにカスタム例外クラスを定義する方法もあるが、多くの場合そこまでの実装は不要である。

メッセージにコンテキストを含める場合の例を以下に示す。後者の形式のほうが情報量を増やしやすく、必要に応じて機械解析もしやすい。

- 「The file report-20250101.pdf is not found.」
- 「The file is not found. - {"filename" : "report-20250101.pdf"}」

## ロギングにおけるマスク処理

ログには個人情報や機密情報などの重要データはなるべく記録しない。
トラブルシューティングのためにデータの一部が必要な場合は必ず大部分をマスクする。

- 例：クレジットカード番号 : #### #### #### 3456
- 例：電話番号 : 090-####-####

## ログ形式と分析のしやすさ

ログはトラブルシューティングのため、あるいは何かしらの分析のために利用される。そのため分析容易な形式が望ましい。

- 特にgrepとの相性をよくするためにはログ出力に含まれる改行はエスケープして1行にするとよい
- ログのテキストを項目ごとに分解できるようにする
  - ログの先頭 (タイムスタンプ、ホスト名、アプリケーション名など) は、一般的にスペース区切りでも問題ない
  - それ以降のメッセージやコンテキスト部分では、区切りが曖昧にならないよう明確なセパレータ (例：「` - `」,「 ` | `」など) を使用する
- ただしスタックトレースについては改行を保ったままにしてログ出力の2行目以降に出力するほうが実用的である
